/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createConditionFromDiscriminatorValue, createListMetaFromDiscriminatorValue, createObjectMetaFromDiscriminatorValue, serializeCondition, serializeListMeta, serializeObjectMeta, type Condition, type ListMeta, type ObjectMeta } from '../../../apimachinery/pkg/apis/meta/v1/index.js';
// @ts-ignore
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IPAddress}
 */
// @ts-ignore
export function createIPAddressFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIPAddress;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IPAddressList}
 */
// @ts-ignore
export function createIPAddressListFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIPAddressList;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IPAddressSpec}
 */
// @ts-ignore
export function createIPAddressSpecFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIPAddressSpec;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ParentReference}
 */
// @ts-ignore
export function createParentReferenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoParentReference;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ServiceCIDR}
 */
// @ts-ignore
export function createServiceCIDRFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoServiceCIDR;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ServiceCIDRList}
 */
// @ts-ignore
export function createServiceCIDRListFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoServiceCIDRList;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ServiceCIDRSpec}
 */
// @ts-ignore
export function createServiceCIDRSpecFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoServiceCIDRSpec;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ServiceCIDRStatus}
 */
// @ts-ignore
export function createServiceCIDRStatusFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoServiceCIDRStatus;
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoIPAddress(iPAddress: Partial<IPAddress> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { iPAddress.apiVersion = n.getStringValue(); },
        "kind": n => { iPAddress.kind = n.getStringValue(); },
        "metadata": n => { iPAddress.metadata = n.getObjectValue<ObjectMeta>(createObjectMetaFromDiscriminatorValue); },
        "spec": n => { iPAddress.spec = n.getObjectValue<IPAddressSpec>(createIPAddressSpecFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoIPAddressList(iPAddressList: Partial<IPAddressList> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { iPAddressList.apiVersion = n.getStringValue(); },
        "items": n => { iPAddressList.items = n.getCollectionOfObjectValues<IPAddress>(createIPAddressFromDiscriminatorValue); },
        "kind": n => { iPAddressList.kind = n.getStringValue(); },
        "metadata": n => { iPAddressList.metadata = n.getObjectValue<ListMeta>(createListMetaFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoIPAddressSpec(iPAddressSpec: Partial<IPAddressSpec> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "parentRef": n => { iPAddressSpec.parentRef = n.getObjectValue<ParentReference>(createParentReferenceFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoParentReference(parentReference: Partial<ParentReference> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "group": n => { parentReference.group = n.getStringValue(); },
        "name": n => { parentReference.name = n.getStringValue(); },
        "namespace": n => { parentReference.namespace = n.getStringValue(); },
        "resource": n => { parentReference.resource = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoServiceCIDR(serviceCIDR: Partial<ServiceCIDR> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { serviceCIDR.apiVersion = n.getStringValue(); },
        "kind": n => { serviceCIDR.kind = n.getStringValue(); },
        "metadata": n => { serviceCIDR.metadata = n.getObjectValue<ObjectMeta>(createObjectMetaFromDiscriminatorValue); },
        "spec": n => { serviceCIDR.spec = n.getObjectValue<ServiceCIDRSpec>(createServiceCIDRSpecFromDiscriminatorValue); },
        "status": n => { serviceCIDR.status = n.getObjectValue<ServiceCIDRStatus>(createServiceCIDRStatusFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoServiceCIDRList(serviceCIDRList: Partial<ServiceCIDRList> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { serviceCIDRList.apiVersion = n.getStringValue(); },
        "items": n => { serviceCIDRList.items = n.getCollectionOfObjectValues<ServiceCIDR>(createServiceCIDRFromDiscriminatorValue); },
        "kind": n => { serviceCIDRList.kind = n.getStringValue(); },
        "metadata": n => { serviceCIDRList.metadata = n.getObjectValue<ListMeta>(createListMetaFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoServiceCIDRSpec(serviceCIDRSpec: Partial<ServiceCIDRSpec> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "cidrs": n => { serviceCIDRSpec.cidrs = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoServiceCIDRStatus(serviceCIDRStatus: Partial<ServiceCIDRStatus> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "conditions": n => { serviceCIDRStatus.conditions = n.getCollectionOfObjectValues<Condition>(createConditionFromDiscriminatorValue); },
    }
}
/**
 * IPAddress represents a single IP of a single IP Family. The object is designed to be used by APIs that operate on IP addresses. The object is used by the Service core API for allocation of IP addresses. An IP address can be represented in different formats, to guarantee the uniqueness of the IP, the name of the object is the IP address in canonical format, four decimal digits separated by dots suppressing leading zeros for IPv4 and the representation defined by RFC 5952 for IPv6. Valid: 192.168.1.5 or 2001:db8::1 or 2001:db8:aaaa:bbbb:cccc:dddd:eeee:1 Invalid: 10.01.2.3 or 2001:db8:0:0:0::1
 */
export interface IPAddress extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
     */
    metadata?: ObjectMeta | null;
    /**
     * IPAddressSpec describe the attributes in an IP Address.
     */
    spec?: IPAddressSpec | null;
}
/**
 * IPAddressList contains a list of IPAddress.
 */
export interface IPAddressList extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * items is the list of IPAddresses.
     */
    items?: IPAddress[] | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
     */
    metadata?: ListMeta | null;
}
/**
 * IPAddressSpec describe the attributes in an IP Address.
 */
export interface IPAddressSpec extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * ParentReference describes a reference to a parent object.
     */
    parentRef?: ParentReference | null;
}
/**
 * ParentReference describes a reference to a parent object.
 */
export interface ParentReference extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Group is the group of the object being referenced.
     */
    group?: string | null;
    /**
     * Name is the name of the object being referenced.
     */
    name?: string | null;
    /**
     * Namespace is the namespace of the object being referenced.
     */
    namespace?: string | null;
    /**
     * Resource is the resource of the object being referenced.
     */
    resource?: string | null;
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeIPAddress(writer: SerializationWriter, iPAddress: Partial<IPAddress> | undefined | null = {}) : void {
    if (iPAddress) {
        writer.writeStringValue("apiVersion", iPAddress.apiVersion);
        writer.writeStringValue("kind", iPAddress.kind);
        writer.writeObjectValue<ObjectMeta>("metadata", iPAddress.metadata, serializeObjectMeta);
        writer.writeObjectValue<IPAddressSpec>("spec", iPAddress.spec, serializeIPAddressSpec);
        writer.writeAdditionalData(iPAddress.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeIPAddressList(writer: SerializationWriter, iPAddressList: Partial<IPAddressList> | undefined | null = {}) : void {
    if (iPAddressList) {
        writer.writeStringValue("apiVersion", iPAddressList.apiVersion);
        writer.writeCollectionOfObjectValues<IPAddress>("items", iPAddressList.items, serializeIPAddress);
        writer.writeStringValue("kind", iPAddressList.kind);
        writer.writeObjectValue<ListMeta>("metadata", iPAddressList.metadata, serializeListMeta);
        writer.writeAdditionalData(iPAddressList.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeIPAddressSpec(writer: SerializationWriter, iPAddressSpec: Partial<IPAddressSpec> | undefined | null = {}) : void {
    if (iPAddressSpec) {
        writer.writeObjectValue<ParentReference>("parentRef", iPAddressSpec.parentRef, serializeParentReference);
        writer.writeAdditionalData(iPAddressSpec.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeParentReference(writer: SerializationWriter, parentReference: Partial<ParentReference> | undefined | null = {}) : void {
    if (parentReference) {
        writer.writeStringValue("group", parentReference.group);
        writer.writeStringValue("name", parentReference.name);
        writer.writeStringValue("namespace", parentReference.namespace);
        writer.writeStringValue("resource", parentReference.resource);
        writer.writeAdditionalData(parentReference.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeServiceCIDR(writer: SerializationWriter, serviceCIDR: Partial<ServiceCIDR> | undefined | null = {}) : void {
    if (serviceCIDR) {
        writer.writeStringValue("apiVersion", serviceCIDR.apiVersion);
        writer.writeStringValue("kind", serviceCIDR.kind);
        writer.writeObjectValue<ObjectMeta>("metadata", serviceCIDR.metadata, serializeObjectMeta);
        writer.writeObjectValue<ServiceCIDRSpec>("spec", serviceCIDR.spec, serializeServiceCIDRSpec);
        writer.writeObjectValue<ServiceCIDRStatus>("status", serviceCIDR.status, serializeServiceCIDRStatus);
        writer.writeAdditionalData(serviceCIDR.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeServiceCIDRList(writer: SerializationWriter, serviceCIDRList: Partial<ServiceCIDRList> | undefined | null = {}) : void {
    if (serviceCIDRList) {
        writer.writeStringValue("apiVersion", serviceCIDRList.apiVersion);
        writer.writeCollectionOfObjectValues<ServiceCIDR>("items", serviceCIDRList.items, serializeServiceCIDR);
        writer.writeStringValue("kind", serviceCIDRList.kind);
        writer.writeObjectValue<ListMeta>("metadata", serviceCIDRList.metadata, serializeListMeta);
        writer.writeAdditionalData(serviceCIDRList.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeServiceCIDRSpec(writer: SerializationWriter, serviceCIDRSpec: Partial<ServiceCIDRSpec> | undefined | null = {}) : void {
    if (serviceCIDRSpec) {
        writer.writeCollectionOfPrimitiveValues<string>("cidrs", serviceCIDRSpec.cidrs);
        writer.writeAdditionalData(serviceCIDRSpec.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeServiceCIDRStatus(writer: SerializationWriter, serviceCIDRStatus: Partial<ServiceCIDRStatus> | undefined | null = {}) : void {
    if (serviceCIDRStatus) {
        writer.writeCollectionOfObjectValues<Condition>("conditions", serviceCIDRStatus.conditions, serializeCondition);
        writer.writeAdditionalData(serviceCIDRStatus.additionalData);
    }
}
/**
 * ServiceCIDR defines a range of IP addresses using CIDR format (e.g. 192.168.0.0/24 or 2001:db2::/64). This range is used to allocate ClusterIPs to Service objects.
 */
export interface ServiceCIDR extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
     */
    metadata?: ObjectMeta | null;
    /**
     * ServiceCIDRSpec define the CIDRs the user wants to use for allocating ClusterIPs for Services.
     */
    spec?: ServiceCIDRSpec | null;
    /**
     * ServiceCIDRStatus describes the current state of the ServiceCIDR.
     */
    status?: ServiceCIDRStatus | null;
}
/**
 * ServiceCIDRList contains a list of ServiceCIDR objects.
 */
export interface ServiceCIDRList extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * items is the list of ServiceCIDRs.
     */
    items?: ServiceCIDR[] | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
     */
    metadata?: ListMeta | null;
}
/**
 * ServiceCIDRSpec define the CIDRs the user wants to use for allocating ClusterIPs for Services.
 */
export interface ServiceCIDRSpec extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * CIDRs defines the IP blocks in CIDR notation (e.g. "192.168.0.0/24" or "2001:db8::/64") from which to assign service cluster IPs. Max of two CIDRs is allowed, one of each IP family. This field is immutable.
     */
    cidrs?: string[] | null;
}
/**
 * ServiceCIDRStatus describes the current state of the ServiceCIDR.
 */
export interface ServiceCIDRStatus extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * conditions holds an array of metav1.Condition that describe the state of the ServiceCIDR. Current service state
     */
    conditions?: Condition[] | null;
}
/* tslint:enable */
/* eslint-enable */
