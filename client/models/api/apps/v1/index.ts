/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createLabelSelectorFromDiscriminatorValue, createListMetaFromDiscriminatorValue, createObjectMetaFromDiscriminatorValue, serializeLabelSelector, serializeListMeta, serializeObjectMeta, type LabelSelector, type ListMeta, type ObjectMeta } from '../../../apimachinery/pkg/apis/meta/v1/index.js';
// @ts-ignore
import { createRawExtensionFromDiscriminatorValue, serializeRawExtension, type RawExtension } from '../../../apimachinery/pkg/runtime/index.js';
// @ts-ignore
import { createPersistentVolumeClaimFromDiscriminatorValue, createPodTemplateSpecFromDiscriminatorValue, serializePersistentVolumeClaim, serializePodTemplateSpec, type PersistentVolumeClaim, type PodTemplateSpec } from '../../core/v1/index.js';
// @ts-ignore
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers.
 */
export interface ControllerRevision extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * RawExtension is used to hold extensions in external versions.To use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.// Internal package:type MyAPIObject struct {runtime.TypeMeta `json:",inline"`MyPlugin runtime.Object `json:"myPlugin"`}type PluginA struct {AOption string `json:"aOption"`}// External package:type MyAPIObject struct {runtime.TypeMeta `json:",inline"`MyPlugin runtime.RawExtension `json:"myPlugin"`}type PluginA struct {AOption string `json:"aOption"`}// On the wire, the JSON will look something like this:{"kind":"MyAPIObject","apiVersion":"v1","myPlugin": {"kind":"PluginA","aOption":"foo",},}So what happens? Decode first uses json or yaml to unmarshal the serialized data into your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked. The next step is to copy (using pkg/conversion) into the internal struct. The runtime package's DefaultScheme has conversion functions installed which will unpack the JSON stored in RawExtension, turning it into the correct object type, and storing it in the Object. (TODO: In the case where the object is of an unknown type, a runtime.Unknown object will be created and stored.)
     */
    data?: RawExtension | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
     */
    metadata?: ObjectMeta | null;
    /**
     * Revision indicates the revision of the state represented by Data.
     */
    revision?: number | null;
}
/**
 * ControllerRevisionList is a resource containing a list of ControllerRevision objects.
 */
export interface ControllerRevisionList extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * Items is the list of ControllerRevisions
     */
    items?: ControllerRevision[] | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
     */
    metadata?: ListMeta | null;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ControllerRevision}
 */
// @ts-ignore
export function createControllerRevisionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoControllerRevision;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ControllerRevisionList}
 */
// @ts-ignore
export function createControllerRevisionListFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoControllerRevisionList;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DaemonSetCondition}
 */
// @ts-ignore
export function createDaemonSetConditionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDaemonSetCondition;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DaemonSet}
 */
// @ts-ignore
export function createDaemonSetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDaemonSet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DaemonSetList}
 */
// @ts-ignore
export function createDaemonSetListFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDaemonSetList;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DaemonSetSpec}
 */
// @ts-ignore
export function createDaemonSetSpecFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDaemonSetSpec;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DaemonSetStatus}
 */
// @ts-ignore
export function createDaemonSetStatusFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDaemonSetStatus;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DaemonSetUpdateStrategy}
 */
// @ts-ignore
export function createDaemonSetUpdateStrategyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDaemonSetUpdateStrategy;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentCondition}
 */
// @ts-ignore
export function createDeploymentConditionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentCondition;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Deployment}
 */
// @ts-ignore
export function createDeploymentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeployment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentList}
 */
// @ts-ignore
export function createDeploymentListFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentList;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentSpec}
 */
// @ts-ignore
export function createDeploymentSpecFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentSpec;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentStatus}
 */
// @ts-ignore
export function createDeploymentStatusFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentStatus;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DeploymentStrategy}
 */
// @ts-ignore
export function createDeploymentStrategyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDeploymentStrategy;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ReplicaSetCondition}
 */
// @ts-ignore
export function createReplicaSetConditionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoReplicaSetCondition;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ReplicaSet}
 */
// @ts-ignore
export function createReplicaSetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoReplicaSet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ReplicaSetList}
 */
// @ts-ignore
export function createReplicaSetListFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoReplicaSetList;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ReplicaSetSpec}
 */
// @ts-ignore
export function createReplicaSetSpecFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoReplicaSetSpec;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ReplicaSetStatus}
 */
// @ts-ignore
export function createReplicaSetStatusFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoReplicaSetStatus;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RollingUpdateDaemonSet}
 */
// @ts-ignore
export function createRollingUpdateDaemonSetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRollingUpdateDaemonSet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RollingUpdateDeployment}
 */
// @ts-ignore
export function createRollingUpdateDeploymentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRollingUpdateDeployment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RollingUpdateStatefulSetStrategy}
 */
// @ts-ignore
export function createRollingUpdateStatefulSetStrategyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRollingUpdateStatefulSetStrategy;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StatefulSetCondition}
 */
// @ts-ignore
export function createStatefulSetConditionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStatefulSetCondition;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StatefulSet}
 */
// @ts-ignore
export function createStatefulSetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStatefulSet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StatefulSetList}
 */
// @ts-ignore
export function createStatefulSetListFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStatefulSetList;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StatefulSetOrdinals}
 */
// @ts-ignore
export function createStatefulSetOrdinalsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStatefulSetOrdinals;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StatefulSetPersistentVolumeClaimRetentionPolicy}
 */
// @ts-ignore
export function createStatefulSetPersistentVolumeClaimRetentionPolicyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStatefulSetPersistentVolumeClaimRetentionPolicy;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StatefulSetSpec}
 */
// @ts-ignore
export function createStatefulSetSpecFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStatefulSetSpec;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StatefulSetStatus}
 */
// @ts-ignore
export function createStatefulSetStatusFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStatefulSetStatus;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StatefulSetUpdateStrategy}
 */
// @ts-ignore
export function createStatefulSetUpdateStrategyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStatefulSetUpdateStrategy;
}
/**
 * DaemonSet represents the configuration of a daemon set.
 */
export interface DaemonSet extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
     */
    metadata?: ObjectMeta | null;
    /**
     * DaemonSetSpec is the specification of a daemon set.
     */
    spec?: DaemonSetSpec | null;
    /**
     * DaemonSetStatus represents the current status of a daemon set.
     */
    status?: DaemonSetStatus | null;
}
/**
 * DaemonSetCondition describes the state of a DaemonSet at a certain point.
 */
export interface DaemonSetCondition extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
     */
    lastTransitionTime?: Date | null;
    /**
     * A human readable message indicating details about the transition.
     */
    message?: string | null;
    /**
     * The reason for the condition's last transition.
     */
    reason?: string | null;
    /**
     * Status of the condition, one of True, False, Unknown.
     */
    status?: string | null;
    /**
     * Type of DaemonSet condition.
     */
    type?: string | null;
}
/**
 * DaemonSetList is a collection of daemon sets.
 */
export interface DaemonSetList extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * A list of daemon sets.
     */
    items?: DaemonSet[] | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
     */
    metadata?: ListMeta | null;
}
/**
 * DaemonSetSpec is the specification of a daemon set.
 */
export interface DaemonSetSpec extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The minimum number of seconds for which a newly created DaemonSet pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready).
     */
    minReadySeconds?: number | null;
    /**
     * The number of old history to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
     */
    revisionHistoryLimit?: number | null;
    /**
     * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
     */
    selector?: LabelSelector | null;
    /**
     * PodTemplateSpec describes the data a pod should have when created from a template
     */
    template?: PodTemplateSpec | null;
    /**
     * DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
     */
    updateStrategy?: DaemonSetUpdateStrategy | null;
}
/**
 * DaemonSetStatus represents the current status of a daemon set.
 */
export interface DaemonSetStatus extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
     */
    collisionCount?: number | null;
    /**
     * Represents the latest available observations of a DaemonSet's current state.
     */
    conditions?: DaemonSetCondition[] | null;
    /**
     * The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     */
    currentNumberScheduled?: number | null;
    /**
     * The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     */
    desiredNumberScheduled?: number | null;
    /**
     * The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)
     */
    numberAvailable?: number | null;
    /**
     * The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     */
    numberMisscheduled?: number | null;
    /**
     * numberReady is the number of nodes that should be running the daemon pod and have one or more of the daemon pod running with a Ready Condition.
     */
    numberReady?: number | null;
    /**
     * The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)
     */
    numberUnavailable?: number | null;
    /**
     * The most recent generation observed by the daemon set controller.
     */
    observedGeneration?: number | null;
    /**
     * The total number of nodes that are running updated daemon pod
     */
    updatedNumberScheduled?: number | null;
}
/**
 * DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
 */
export interface DaemonSetUpdateStrategy extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Spec to control the desired behavior of daemon set rolling update.
     */
    rollingUpdate?: RollingUpdateDaemonSet | null;
    /**
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
     */
    type?: string | null;
}
/**
 * Deployment enables declarative updates for Pods and ReplicaSets.
 */
export interface Deployment extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
     */
    metadata?: ObjectMeta | null;
    /**
     * DeploymentSpec is the specification of the desired behavior of the Deployment.
     */
    spec?: DeploymentSpec | null;
    /**
     * DeploymentStatus is the most recently observed status of the Deployment.
     */
    status?: DeploymentStatus | null;
}
/**
 * DeploymentCondition describes the state of a deployment at a certain point.
 */
export interface DeploymentCondition extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
     */
    lastTransitionTime?: Date | null;
    /**
     * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
     */
    lastUpdateTime?: Date | null;
    /**
     * A human readable message indicating details about the transition.
     */
    message?: string | null;
    /**
     * The reason for the condition's last transition.
     */
    reason?: string | null;
    /**
     * Status of the condition, one of True, False, Unknown.
     */
    status?: string | null;
    /**
     * Type of deployment condition.
     */
    type?: string | null;
}
/**
 * DeploymentList is a list of Deployments.
 */
export interface DeploymentList extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * Items is the list of Deployments.
     */
    items?: Deployment[] | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
     */
    metadata?: ListMeta | null;
}
/**
 * DeploymentSpec is the specification of the desired behavior of the Deployment.
 */
export interface DeploymentSpec extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
     */
    minReadySeconds?: number | null;
    /**
     * Indicates that the deployment is paused.
     */
    paused?: boolean | null;
    /**
     * The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.
     */
    progressDeadlineSeconds?: number | null;
    /**
     * Number of desired pods. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
     */
    replicas?: number | null;
    /**
     * The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
     */
    revisionHistoryLimit?: number | null;
    /**
     * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
     */
    selector?: LabelSelector | null;
    /**
     * DeploymentStrategy describes how to replace existing pods with new ones.
     */
    strategy?: DeploymentStrategy | null;
    /**
     * PodTemplateSpec describes the data a pod should have when created from a template
     */
    template?: PodTemplateSpec | null;
}
/**
 * DeploymentStatus is the most recently observed status of the Deployment.
 */
export interface DeploymentStatus extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Total number of available non-terminating pods (ready for at least minReadySeconds) targeted by this deployment.
     */
    availableReplicas?: number | null;
    /**
     * Count of hash collisions for the Deployment. The Deployment controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ReplicaSet.
     */
    collisionCount?: number | null;
    /**
     * Represents the latest available observations of a deployment's current state.
     */
    conditions?: DeploymentCondition[] | null;
    /**
     * The generation observed by the deployment controller.
     */
    observedGeneration?: number | null;
    /**
     * Total number of non-terminating pods targeted by this Deployment with a Ready Condition.
     */
    readyReplicas?: number | null;
    /**
     * Total number of non-terminating pods targeted by this deployment (their labels match the selector).
     */
    replicas?: number | null;
    /**
     * Total number of terminating pods targeted by this deployment. Terminating pods have a non-null .metadata.deletionTimestamp and have not yet reached the Failed or Succeeded .status.phase.This is an alpha field. Enable DeploymentPodReplacementPolicy to be able to use this field.
     */
    terminatingReplicas?: number | null;
    /**
     * Total number of unavailable pods targeted by this deployment. This is the total number of pods that are still required for the deployment to have 100% available capacity. They may either be pods that are running but not yet available or pods that still have not been created.
     */
    unavailableReplicas?: number | null;
    /**
     * Total number of non-terminating pods targeted by this deployment that have the desired template spec.
     */
    updatedReplicas?: number | null;
}
/**
 * DeploymentStrategy describes how to replace existing pods with new ones.
 */
export interface DeploymentStrategy extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Spec to control the desired behavior of rolling update.
     */
    rollingUpdate?: RollingUpdateDeployment | null;
    /**
     * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
     */
    type?: string | null;
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoControllerRevision(controllerRevision: Partial<ControllerRevision> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { controllerRevision.apiVersion = n.getStringValue(); },
        "data": n => { controllerRevision.data = n.getObjectValue<RawExtension>(createRawExtensionFromDiscriminatorValue); },
        "kind": n => { controllerRevision.kind = n.getStringValue(); },
        "metadata": n => { controllerRevision.metadata = n.getObjectValue<ObjectMeta>(createObjectMetaFromDiscriminatorValue); },
        "revision": n => { controllerRevision.revision = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoControllerRevisionList(controllerRevisionList: Partial<ControllerRevisionList> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { controllerRevisionList.apiVersion = n.getStringValue(); },
        "items": n => { controllerRevisionList.items = n.getCollectionOfObjectValues<ControllerRevision>(createControllerRevisionFromDiscriminatorValue); },
        "kind": n => { controllerRevisionList.kind = n.getStringValue(); },
        "metadata": n => { controllerRevisionList.metadata = n.getObjectValue<ListMeta>(createListMetaFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDaemonSet(daemonSet: Partial<DaemonSet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { daemonSet.apiVersion = n.getStringValue(); },
        "kind": n => { daemonSet.kind = n.getStringValue(); },
        "metadata": n => { daemonSet.metadata = n.getObjectValue<ObjectMeta>(createObjectMetaFromDiscriminatorValue); },
        "spec": n => { daemonSet.spec = n.getObjectValue<DaemonSetSpec>(createDaemonSetSpecFromDiscriminatorValue); },
        "status": n => { daemonSet.status = n.getObjectValue<DaemonSetStatus>(createDaemonSetStatusFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDaemonSetCondition(daemonSetCondition: Partial<DaemonSetCondition> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "lastTransitionTime": n => { daemonSetCondition.lastTransitionTime = n.getDateValue(); },
        "message": n => { daemonSetCondition.message = n.getStringValue(); },
        "reason": n => { daemonSetCondition.reason = n.getStringValue(); },
        "status": n => { daemonSetCondition.status = n.getStringValue(); },
        "type": n => { daemonSetCondition.type = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDaemonSetList(daemonSetList: Partial<DaemonSetList> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { daemonSetList.apiVersion = n.getStringValue(); },
        "items": n => { daemonSetList.items = n.getCollectionOfObjectValues<DaemonSet>(createDaemonSetFromDiscriminatorValue); },
        "kind": n => { daemonSetList.kind = n.getStringValue(); },
        "metadata": n => { daemonSetList.metadata = n.getObjectValue<ListMeta>(createListMetaFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDaemonSetSpec(daemonSetSpec: Partial<DaemonSetSpec> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "minReadySeconds": n => { daemonSetSpec.minReadySeconds = n.getNumberValue(); },
        "revisionHistoryLimit": n => { daemonSetSpec.revisionHistoryLimit = n.getNumberValue(); },
        "selector": n => { daemonSetSpec.selector = n.getObjectValue<LabelSelector>(createLabelSelectorFromDiscriminatorValue); },
        "template": n => { daemonSetSpec.template = n.getObjectValue<PodTemplateSpec>(createPodTemplateSpecFromDiscriminatorValue); },
        "updateStrategy": n => { daemonSetSpec.updateStrategy = n.getObjectValue<DaemonSetUpdateStrategy>(createDaemonSetUpdateStrategyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDaemonSetStatus(daemonSetStatus: Partial<DaemonSetStatus> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "collisionCount": n => { daemonSetStatus.collisionCount = n.getNumberValue(); },
        "conditions": n => { daemonSetStatus.conditions = n.getCollectionOfObjectValues<DaemonSetCondition>(createDaemonSetConditionFromDiscriminatorValue); },
        "currentNumberScheduled": n => { daemonSetStatus.currentNumberScheduled = n.getNumberValue(); },
        "desiredNumberScheduled": n => { daemonSetStatus.desiredNumberScheduled = n.getNumberValue(); },
        "numberAvailable": n => { daemonSetStatus.numberAvailable = n.getNumberValue(); },
        "numberMisscheduled": n => { daemonSetStatus.numberMisscheduled = n.getNumberValue(); },
        "numberReady": n => { daemonSetStatus.numberReady = n.getNumberValue(); },
        "numberUnavailable": n => { daemonSetStatus.numberUnavailable = n.getNumberValue(); },
        "observedGeneration": n => { daemonSetStatus.observedGeneration = n.getNumberValue(); },
        "updatedNumberScheduled": n => { daemonSetStatus.updatedNumberScheduled = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDaemonSetUpdateStrategy(daemonSetUpdateStrategy: Partial<DaemonSetUpdateStrategy> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "rollingUpdate": n => { daemonSetUpdateStrategy.rollingUpdate = n.getObjectValue<RollingUpdateDaemonSet>(createRollingUpdateDaemonSetFromDiscriminatorValue); },
        "type": n => { daemonSetUpdateStrategy.type = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeployment(deployment: Partial<Deployment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { deployment.apiVersion = n.getStringValue(); },
        "kind": n => { deployment.kind = n.getStringValue(); },
        "metadata": n => { deployment.metadata = n.getObjectValue<ObjectMeta>(createObjectMetaFromDiscriminatorValue); },
        "spec": n => { deployment.spec = n.getObjectValue<DeploymentSpec>(createDeploymentSpecFromDiscriminatorValue); },
        "status": n => { deployment.status = n.getObjectValue<DeploymentStatus>(createDeploymentStatusFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeploymentCondition(deploymentCondition: Partial<DeploymentCondition> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "lastTransitionTime": n => { deploymentCondition.lastTransitionTime = n.getDateValue(); },
        "lastUpdateTime": n => { deploymentCondition.lastUpdateTime = n.getDateValue(); },
        "message": n => { deploymentCondition.message = n.getStringValue(); },
        "reason": n => { deploymentCondition.reason = n.getStringValue(); },
        "status": n => { deploymentCondition.status = n.getStringValue(); },
        "type": n => { deploymentCondition.type = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeploymentList(deploymentList: Partial<DeploymentList> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { deploymentList.apiVersion = n.getStringValue(); },
        "items": n => { deploymentList.items = n.getCollectionOfObjectValues<Deployment>(createDeploymentFromDiscriminatorValue); },
        "kind": n => { deploymentList.kind = n.getStringValue(); },
        "metadata": n => { deploymentList.metadata = n.getObjectValue<ListMeta>(createListMetaFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeploymentSpec(deploymentSpec: Partial<DeploymentSpec> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "minReadySeconds": n => { deploymentSpec.minReadySeconds = n.getNumberValue(); },
        "paused": n => { deploymentSpec.paused = n.getBooleanValue(); },
        "progressDeadlineSeconds": n => { deploymentSpec.progressDeadlineSeconds = n.getNumberValue(); },
        "replicas": n => { deploymentSpec.replicas = n.getNumberValue(); },
        "revisionHistoryLimit": n => { deploymentSpec.revisionHistoryLimit = n.getNumberValue(); },
        "selector": n => { deploymentSpec.selector = n.getObjectValue<LabelSelector>(createLabelSelectorFromDiscriminatorValue); },
        "strategy": n => { deploymentSpec.strategy = n.getObjectValue<DeploymentStrategy>(createDeploymentStrategyFromDiscriminatorValue); },
        "template": n => { deploymentSpec.template = n.getObjectValue<PodTemplateSpec>(createPodTemplateSpecFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeploymentStatus(deploymentStatus: Partial<DeploymentStatus> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "availableReplicas": n => { deploymentStatus.availableReplicas = n.getNumberValue(); },
        "collisionCount": n => { deploymentStatus.collisionCount = n.getNumberValue(); },
        "conditions": n => { deploymentStatus.conditions = n.getCollectionOfObjectValues<DeploymentCondition>(createDeploymentConditionFromDiscriminatorValue); },
        "observedGeneration": n => { deploymentStatus.observedGeneration = n.getNumberValue(); },
        "readyReplicas": n => { deploymentStatus.readyReplicas = n.getNumberValue(); },
        "replicas": n => { deploymentStatus.replicas = n.getNumberValue(); },
        "terminatingReplicas": n => { deploymentStatus.terminatingReplicas = n.getNumberValue(); },
        "unavailableReplicas": n => { deploymentStatus.unavailableReplicas = n.getNumberValue(); },
        "updatedReplicas": n => { deploymentStatus.updatedReplicas = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDeploymentStrategy(deploymentStrategy: Partial<DeploymentStrategy> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "rollingUpdate": n => { deploymentStrategy.rollingUpdate = n.getObjectValue<RollingUpdateDeployment>(createRollingUpdateDeploymentFromDiscriminatorValue); },
        "type": n => { deploymentStrategy.type = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoReplicaSet(replicaSet: Partial<ReplicaSet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { replicaSet.apiVersion = n.getStringValue(); },
        "kind": n => { replicaSet.kind = n.getStringValue(); },
        "metadata": n => { replicaSet.metadata = n.getObjectValue<ObjectMeta>(createObjectMetaFromDiscriminatorValue); },
        "spec": n => { replicaSet.spec = n.getObjectValue<ReplicaSetSpec>(createReplicaSetSpecFromDiscriminatorValue); },
        "status": n => { replicaSet.status = n.getObjectValue<ReplicaSetStatus>(createReplicaSetStatusFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoReplicaSetCondition(replicaSetCondition: Partial<ReplicaSetCondition> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "lastTransitionTime": n => { replicaSetCondition.lastTransitionTime = n.getDateValue(); },
        "message": n => { replicaSetCondition.message = n.getStringValue(); },
        "reason": n => { replicaSetCondition.reason = n.getStringValue(); },
        "status": n => { replicaSetCondition.status = n.getStringValue(); },
        "type": n => { replicaSetCondition.type = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoReplicaSetList(replicaSetList: Partial<ReplicaSetList> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { replicaSetList.apiVersion = n.getStringValue(); },
        "items": n => { replicaSetList.items = n.getCollectionOfObjectValues<ReplicaSet>(createReplicaSetFromDiscriminatorValue); },
        "kind": n => { replicaSetList.kind = n.getStringValue(); },
        "metadata": n => { replicaSetList.metadata = n.getObjectValue<ListMeta>(createListMetaFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoReplicaSetSpec(replicaSetSpec: Partial<ReplicaSetSpec> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "minReadySeconds": n => { replicaSetSpec.minReadySeconds = n.getNumberValue(); },
        "replicas": n => { replicaSetSpec.replicas = n.getNumberValue(); },
        "selector": n => { replicaSetSpec.selector = n.getObjectValue<LabelSelector>(createLabelSelectorFromDiscriminatorValue); },
        "template": n => { replicaSetSpec.template = n.getObjectValue<PodTemplateSpec>(createPodTemplateSpecFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoReplicaSetStatus(replicaSetStatus: Partial<ReplicaSetStatus> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "availableReplicas": n => { replicaSetStatus.availableReplicas = n.getNumberValue(); },
        "conditions": n => { replicaSetStatus.conditions = n.getCollectionOfObjectValues<ReplicaSetCondition>(createReplicaSetConditionFromDiscriminatorValue); },
        "fullyLabeledReplicas": n => { replicaSetStatus.fullyLabeledReplicas = n.getNumberValue(); },
        "observedGeneration": n => { replicaSetStatus.observedGeneration = n.getNumberValue(); },
        "readyReplicas": n => { replicaSetStatus.readyReplicas = n.getNumberValue(); },
        "replicas": n => { replicaSetStatus.replicas = n.getNumberValue(); },
        "terminatingReplicas": n => { replicaSetStatus.terminatingReplicas = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRollingUpdateDaemonSet(rollingUpdateDaemonSet: Partial<RollingUpdateDaemonSet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "maxSurge": n => { rollingUpdateDaemonSet.maxSurge = n.getStringValue(); },
        "maxUnavailable": n => { rollingUpdateDaemonSet.maxUnavailable = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRollingUpdateDeployment(rollingUpdateDeployment: Partial<RollingUpdateDeployment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "maxSurge": n => { rollingUpdateDeployment.maxSurge = n.getStringValue(); },
        "maxUnavailable": n => { rollingUpdateDeployment.maxUnavailable = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRollingUpdateStatefulSetStrategy(rollingUpdateStatefulSetStrategy: Partial<RollingUpdateStatefulSetStrategy> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "maxUnavailable": n => { rollingUpdateStatefulSetStrategy.maxUnavailable = n.getStringValue(); },
        "partition": n => { rollingUpdateStatefulSetStrategy.partition = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStatefulSet(statefulSet: Partial<StatefulSet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { statefulSet.apiVersion = n.getStringValue(); },
        "kind": n => { statefulSet.kind = n.getStringValue(); },
        "metadata": n => { statefulSet.metadata = n.getObjectValue<ObjectMeta>(createObjectMetaFromDiscriminatorValue); },
        "spec": n => { statefulSet.spec = n.getObjectValue<StatefulSetSpec>(createStatefulSetSpecFromDiscriminatorValue); },
        "status": n => { statefulSet.status = n.getObjectValue<StatefulSetStatus>(createStatefulSetStatusFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStatefulSetCondition(statefulSetCondition: Partial<StatefulSetCondition> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "lastTransitionTime": n => { statefulSetCondition.lastTransitionTime = n.getDateValue(); },
        "message": n => { statefulSetCondition.message = n.getStringValue(); },
        "reason": n => { statefulSetCondition.reason = n.getStringValue(); },
        "status": n => { statefulSetCondition.status = n.getStringValue(); },
        "type": n => { statefulSetCondition.type = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStatefulSetList(statefulSetList: Partial<StatefulSetList> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { statefulSetList.apiVersion = n.getStringValue(); },
        "items": n => { statefulSetList.items = n.getCollectionOfObjectValues<StatefulSet>(createStatefulSetFromDiscriminatorValue); },
        "kind": n => { statefulSetList.kind = n.getStringValue(); },
        "metadata": n => { statefulSetList.metadata = n.getObjectValue<ListMeta>(createListMetaFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStatefulSetOrdinals(statefulSetOrdinals: Partial<StatefulSetOrdinals> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "start": n => { statefulSetOrdinals.start = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStatefulSetPersistentVolumeClaimRetentionPolicy(statefulSetPersistentVolumeClaimRetentionPolicy: Partial<StatefulSetPersistentVolumeClaimRetentionPolicy> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "whenDeleted": n => { statefulSetPersistentVolumeClaimRetentionPolicy.whenDeleted = n.getStringValue(); },
        "whenScaled": n => { statefulSetPersistentVolumeClaimRetentionPolicy.whenScaled = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStatefulSetSpec(statefulSetSpec: Partial<StatefulSetSpec> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "minReadySeconds": n => { statefulSetSpec.minReadySeconds = n.getNumberValue(); },
        "ordinals": n => { statefulSetSpec.ordinals = n.getObjectValue<StatefulSetOrdinals>(createStatefulSetOrdinalsFromDiscriminatorValue); },
        "persistentVolumeClaimRetentionPolicy": n => { statefulSetSpec.persistentVolumeClaimRetentionPolicy = n.getObjectValue<StatefulSetPersistentVolumeClaimRetentionPolicy>(createStatefulSetPersistentVolumeClaimRetentionPolicyFromDiscriminatorValue); },
        "podManagementPolicy": n => { statefulSetSpec.podManagementPolicy = n.getStringValue(); },
        "replicas": n => { statefulSetSpec.replicas = n.getNumberValue(); },
        "revisionHistoryLimit": n => { statefulSetSpec.revisionHistoryLimit = n.getNumberValue(); },
        "selector": n => { statefulSetSpec.selector = n.getObjectValue<LabelSelector>(createLabelSelectorFromDiscriminatorValue); },
        "serviceName": n => { statefulSetSpec.serviceName = n.getStringValue(); },
        "template": n => { statefulSetSpec.template = n.getObjectValue<PodTemplateSpec>(createPodTemplateSpecFromDiscriminatorValue); },
        "updateStrategy": n => { statefulSetSpec.updateStrategy = n.getObjectValue<StatefulSetUpdateStrategy>(createStatefulSetUpdateStrategyFromDiscriminatorValue); },
        "volumeClaimTemplates": n => { statefulSetSpec.volumeClaimTemplates = n.getCollectionOfObjectValues<PersistentVolumeClaim>(createPersistentVolumeClaimFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStatefulSetStatus(statefulSetStatus: Partial<StatefulSetStatus> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "availableReplicas": n => { statefulSetStatus.availableReplicas = n.getNumberValue(); },
        "collisionCount": n => { statefulSetStatus.collisionCount = n.getNumberValue(); },
        "conditions": n => { statefulSetStatus.conditions = n.getCollectionOfObjectValues<StatefulSetCondition>(createStatefulSetConditionFromDiscriminatorValue); },
        "currentReplicas": n => { statefulSetStatus.currentReplicas = n.getNumberValue(); },
        "currentRevision": n => { statefulSetStatus.currentRevision = n.getStringValue(); },
        "observedGeneration": n => { statefulSetStatus.observedGeneration = n.getNumberValue(); },
        "readyReplicas": n => { statefulSetStatus.readyReplicas = n.getNumberValue(); },
        "replicas": n => { statefulSetStatus.replicas = n.getNumberValue(); },
        "updatedReplicas": n => { statefulSetStatus.updatedReplicas = n.getNumberValue(); },
        "updateRevision": n => { statefulSetStatus.updateRevision = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStatefulSetUpdateStrategy(statefulSetUpdateStrategy: Partial<StatefulSetUpdateStrategy> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "rollingUpdate": n => { statefulSetUpdateStrategy.rollingUpdate = n.getObjectValue<RollingUpdateStatefulSetStrategy>(createRollingUpdateStatefulSetStrategyFromDiscriminatorValue); },
        "type": n => { statefulSetUpdateStrategy.type = n.getStringValue(); },
    }
}
/**
 * ReplicaSet ensures that a specified number of pod replicas are running at any given time.
 */
export interface ReplicaSet extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
     */
    metadata?: ObjectMeta | null;
    /**
     * ReplicaSetSpec is the specification of a ReplicaSet.
     */
    spec?: ReplicaSetSpec | null;
    /**
     * ReplicaSetStatus represents the current status of a ReplicaSet.
     */
    status?: ReplicaSetStatus | null;
}
/**
 * ReplicaSetCondition describes the state of a replica set at a certain point.
 */
export interface ReplicaSetCondition extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
     */
    lastTransitionTime?: Date | null;
    /**
     * A human readable message indicating details about the transition.
     */
    message?: string | null;
    /**
     * The reason for the condition's last transition.
     */
    reason?: string | null;
    /**
     * Status of the condition, one of True, False, Unknown.
     */
    status?: string | null;
    /**
     * Type of replica set condition.
     */
    type?: string | null;
}
/**
 * ReplicaSetList is a collection of ReplicaSets.
 */
export interface ReplicaSetList extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * List of ReplicaSets. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset
     */
    items?: ReplicaSet[] | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
     */
    metadata?: ListMeta | null;
}
/**
 * ReplicaSetSpec is the specification of a ReplicaSet.
 */
export interface ReplicaSetSpec extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
     */
    minReadySeconds?: number | null;
    /**
     * Replicas is the number of desired pods. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset
     */
    replicas?: number | null;
    /**
     * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
     */
    selector?: LabelSelector | null;
    /**
     * PodTemplateSpec describes the data a pod should have when created from a template
     */
    template?: PodTemplateSpec | null;
}
/**
 * ReplicaSetStatus represents the current status of a ReplicaSet.
 */
export interface ReplicaSetStatus extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The number of available non-terminating pods (ready for at least minReadySeconds) for this replica set.
     */
    availableReplicas?: number | null;
    /**
     * Represents the latest available observations of a replica set's current state.
     */
    conditions?: ReplicaSetCondition[] | null;
    /**
     * The number of non-terminating pods that have labels matching the labels of the pod template of the replicaset.
     */
    fullyLabeledReplicas?: number | null;
    /**
     * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
     */
    observedGeneration?: number | null;
    /**
     * The number of non-terminating pods targeted by this ReplicaSet with a Ready Condition.
     */
    readyReplicas?: number | null;
    /**
     * Replicas is the most recently observed number of non-terminating pods. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset
     */
    replicas?: number | null;
    /**
     * The number of terminating pods for this replica set. Terminating pods have a non-null .metadata.deletionTimestamp and have not yet reached the Failed or Succeeded .status.phase.This is an alpha field. Enable DeploymentPodReplacementPolicy to be able to use this field.
     */
    terminatingReplicas?: number | null;
}
/**
 * Spec to control the desired behavior of daemon set rolling update.
 */
export interface RollingUpdateDaemonSet extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * IntOrString is a type that can hold an int32 or a string.  When used in JSON or YAML marshalling and unmarshalling, it produces or consumes the inner type.  This allows you to have, for example, a JSON field that can accept a name or number.
     */
    maxSurge?: string | null;
    /**
     * IntOrString is a type that can hold an int32 or a string.  When used in JSON or YAML marshalling and unmarshalling, it produces or consumes the inner type.  This allows you to have, for example, a JSON field that can accept a name or number.
     */
    maxUnavailable?: string | null;
}
/**
 * Spec to control the desired behavior of rolling update.
 */
export interface RollingUpdateDeployment extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * IntOrString is a type that can hold an int32 or a string.  When used in JSON or YAML marshalling and unmarshalling, it produces or consumes the inner type.  This allows you to have, for example, a JSON field that can accept a name or number.
     */
    maxSurge?: string | null;
    /**
     * IntOrString is a type that can hold an int32 or a string.  When used in JSON or YAML marshalling and unmarshalling, it produces or consumes the inner type.  This allows you to have, for example, a JSON field that can accept a name or number.
     */
    maxUnavailable?: string | null;
}
/**
 * RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
 */
export interface RollingUpdateStatefulSetStrategy extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * IntOrString is a type that can hold an int32 or a string.  When used in JSON or YAML marshalling and unmarshalling, it produces or consumes the inner type.  This allows you to have, for example, a JSON field that can accept a name or number.
     */
    maxUnavailable?: string | null;
    /**
     * Partition indicates the ordinal at which the StatefulSet should be partitioned for updates. During a rolling update, all pods from ordinal Replicas-1 to Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched. This is helpful in being able to do a canary based deployment. The default value is 0.
     */
    partition?: number | null;
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeControllerRevision(writer: SerializationWriter, controllerRevision: Partial<ControllerRevision> | undefined | null = {}) : void {
    if (controllerRevision) {
        writer.writeStringValue("apiVersion", controllerRevision.apiVersion);
        writer.writeObjectValue<RawExtension>("data", controllerRevision.data, serializeRawExtension);
        writer.writeStringValue("kind", controllerRevision.kind);
        writer.writeObjectValue<ObjectMeta>("metadata", controllerRevision.metadata, serializeObjectMeta);
        writer.writeNumberValue("revision", controllerRevision.revision);
        writer.writeAdditionalData(controllerRevision.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeControllerRevisionList(writer: SerializationWriter, controllerRevisionList: Partial<ControllerRevisionList> | undefined | null = {}) : void {
    if (controllerRevisionList) {
        writer.writeStringValue("apiVersion", controllerRevisionList.apiVersion);
        writer.writeCollectionOfObjectValues<ControllerRevision>("items", controllerRevisionList.items, serializeControllerRevision);
        writer.writeStringValue("kind", controllerRevisionList.kind);
        writer.writeObjectValue<ListMeta>("metadata", controllerRevisionList.metadata, serializeListMeta);
        writer.writeAdditionalData(controllerRevisionList.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDaemonSet(writer: SerializationWriter, daemonSet: Partial<DaemonSet> | undefined | null = {}) : void {
    if (daemonSet) {
        writer.writeStringValue("apiVersion", daemonSet.apiVersion);
        writer.writeStringValue("kind", daemonSet.kind);
        writer.writeObjectValue<ObjectMeta>("metadata", daemonSet.metadata, serializeObjectMeta);
        writer.writeObjectValue<DaemonSetSpec>("spec", daemonSet.spec, serializeDaemonSetSpec);
        writer.writeObjectValue<DaemonSetStatus>("status", daemonSet.status, serializeDaemonSetStatus);
        writer.writeAdditionalData(daemonSet.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDaemonSetCondition(writer: SerializationWriter, daemonSetCondition: Partial<DaemonSetCondition> | undefined | null = {}) : void {
    if (daemonSetCondition) {
        writer.writeDateValue("lastTransitionTime", daemonSetCondition.lastTransitionTime);
        writer.writeStringValue("message", daemonSetCondition.message);
        writer.writeStringValue("reason", daemonSetCondition.reason);
        writer.writeStringValue("status", daemonSetCondition.status);
        writer.writeStringValue("type", daemonSetCondition.type);
        writer.writeAdditionalData(daemonSetCondition.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDaemonSetList(writer: SerializationWriter, daemonSetList: Partial<DaemonSetList> | undefined | null = {}) : void {
    if (daemonSetList) {
        writer.writeStringValue("apiVersion", daemonSetList.apiVersion);
        writer.writeCollectionOfObjectValues<DaemonSet>("items", daemonSetList.items, serializeDaemonSet);
        writer.writeStringValue("kind", daemonSetList.kind);
        writer.writeObjectValue<ListMeta>("metadata", daemonSetList.metadata, serializeListMeta);
        writer.writeAdditionalData(daemonSetList.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDaemonSetSpec(writer: SerializationWriter, daemonSetSpec: Partial<DaemonSetSpec> | undefined | null = {}) : void {
    if (daemonSetSpec) {
        writer.writeNumberValue("minReadySeconds", daemonSetSpec.minReadySeconds);
        writer.writeNumberValue("revisionHistoryLimit", daemonSetSpec.revisionHistoryLimit);
        writer.writeObjectValue<LabelSelector>("selector", daemonSetSpec.selector, serializeLabelSelector);
        writer.writeObjectValue<PodTemplateSpec>("template", daemonSetSpec.template, serializePodTemplateSpec);
        writer.writeObjectValue<DaemonSetUpdateStrategy>("updateStrategy", daemonSetSpec.updateStrategy, serializeDaemonSetUpdateStrategy);
        writer.writeAdditionalData(daemonSetSpec.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDaemonSetStatus(writer: SerializationWriter, daemonSetStatus: Partial<DaemonSetStatus> | undefined | null = {}) : void {
    if (daemonSetStatus) {
        writer.writeNumberValue("collisionCount", daemonSetStatus.collisionCount);
        writer.writeCollectionOfObjectValues<DaemonSetCondition>("conditions", daemonSetStatus.conditions, serializeDaemonSetCondition);
        writer.writeNumberValue("currentNumberScheduled", daemonSetStatus.currentNumberScheduled);
        writer.writeNumberValue("desiredNumberScheduled", daemonSetStatus.desiredNumberScheduled);
        writer.writeNumberValue("numberAvailable", daemonSetStatus.numberAvailable);
        writer.writeNumberValue("numberMisscheduled", daemonSetStatus.numberMisscheduled);
        writer.writeNumberValue("numberReady", daemonSetStatus.numberReady);
        writer.writeNumberValue("numberUnavailable", daemonSetStatus.numberUnavailable);
        writer.writeNumberValue("observedGeneration", daemonSetStatus.observedGeneration);
        writer.writeNumberValue("updatedNumberScheduled", daemonSetStatus.updatedNumberScheduled);
        writer.writeAdditionalData(daemonSetStatus.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDaemonSetUpdateStrategy(writer: SerializationWriter, daemonSetUpdateStrategy: Partial<DaemonSetUpdateStrategy> | undefined | null = {}) : void {
    if (daemonSetUpdateStrategy) {
        writer.writeObjectValue<RollingUpdateDaemonSet>("rollingUpdate", daemonSetUpdateStrategy.rollingUpdate, serializeRollingUpdateDaemonSet);
        writer.writeStringValue("type", daemonSetUpdateStrategy.type);
        writer.writeAdditionalData(daemonSetUpdateStrategy.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeployment(writer: SerializationWriter, deployment: Partial<Deployment> | undefined | null = {}) : void {
    if (deployment) {
        writer.writeStringValue("apiVersion", deployment.apiVersion);
        writer.writeStringValue("kind", deployment.kind);
        writer.writeObjectValue<ObjectMeta>("metadata", deployment.metadata, serializeObjectMeta);
        writer.writeObjectValue<DeploymentSpec>("spec", deployment.spec, serializeDeploymentSpec);
        writer.writeObjectValue<DeploymentStatus>("status", deployment.status, serializeDeploymentStatus);
        writer.writeAdditionalData(deployment.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeploymentCondition(writer: SerializationWriter, deploymentCondition: Partial<DeploymentCondition> | undefined | null = {}) : void {
    if (deploymentCondition) {
        writer.writeDateValue("lastTransitionTime", deploymentCondition.lastTransitionTime);
        writer.writeDateValue("lastUpdateTime", deploymentCondition.lastUpdateTime);
        writer.writeStringValue("message", deploymentCondition.message);
        writer.writeStringValue("reason", deploymentCondition.reason);
        writer.writeStringValue("status", deploymentCondition.status);
        writer.writeStringValue("type", deploymentCondition.type);
        writer.writeAdditionalData(deploymentCondition.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeploymentList(writer: SerializationWriter, deploymentList: Partial<DeploymentList> | undefined | null = {}) : void {
    if (deploymentList) {
        writer.writeStringValue("apiVersion", deploymentList.apiVersion);
        writer.writeCollectionOfObjectValues<Deployment>("items", deploymentList.items, serializeDeployment);
        writer.writeStringValue("kind", deploymentList.kind);
        writer.writeObjectValue<ListMeta>("metadata", deploymentList.metadata, serializeListMeta);
        writer.writeAdditionalData(deploymentList.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeploymentSpec(writer: SerializationWriter, deploymentSpec: Partial<DeploymentSpec> | undefined | null = {}) : void {
    if (deploymentSpec) {
        writer.writeNumberValue("minReadySeconds", deploymentSpec.minReadySeconds);
        writer.writeBooleanValue("paused", deploymentSpec.paused);
        writer.writeNumberValue("progressDeadlineSeconds", deploymentSpec.progressDeadlineSeconds);
        writer.writeNumberValue("replicas", deploymentSpec.replicas);
        writer.writeNumberValue("revisionHistoryLimit", deploymentSpec.revisionHistoryLimit);
        writer.writeObjectValue<LabelSelector>("selector", deploymentSpec.selector, serializeLabelSelector);
        writer.writeObjectValue<DeploymentStrategy>("strategy", deploymentSpec.strategy, serializeDeploymentStrategy);
        writer.writeObjectValue<PodTemplateSpec>("template", deploymentSpec.template, serializePodTemplateSpec);
        writer.writeAdditionalData(deploymentSpec.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeploymentStatus(writer: SerializationWriter, deploymentStatus: Partial<DeploymentStatus> | undefined | null = {}) : void {
    if (deploymentStatus) {
        writer.writeNumberValue("availableReplicas", deploymentStatus.availableReplicas);
        writer.writeNumberValue("collisionCount", deploymentStatus.collisionCount);
        writer.writeCollectionOfObjectValues<DeploymentCondition>("conditions", deploymentStatus.conditions, serializeDeploymentCondition);
        writer.writeNumberValue("observedGeneration", deploymentStatus.observedGeneration);
        writer.writeNumberValue("readyReplicas", deploymentStatus.readyReplicas);
        writer.writeNumberValue("replicas", deploymentStatus.replicas);
        writer.writeNumberValue("terminatingReplicas", deploymentStatus.terminatingReplicas);
        writer.writeNumberValue("unavailableReplicas", deploymentStatus.unavailableReplicas);
        writer.writeNumberValue("updatedReplicas", deploymentStatus.updatedReplicas);
        writer.writeAdditionalData(deploymentStatus.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDeploymentStrategy(writer: SerializationWriter, deploymentStrategy: Partial<DeploymentStrategy> | undefined | null = {}) : void {
    if (deploymentStrategy) {
        writer.writeObjectValue<RollingUpdateDeployment>("rollingUpdate", deploymentStrategy.rollingUpdate, serializeRollingUpdateDeployment);
        writer.writeStringValue("type", deploymentStrategy.type);
        writer.writeAdditionalData(deploymentStrategy.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeReplicaSet(writer: SerializationWriter, replicaSet: Partial<ReplicaSet> | undefined | null = {}) : void {
    if (replicaSet) {
        writer.writeStringValue("apiVersion", replicaSet.apiVersion);
        writer.writeStringValue("kind", replicaSet.kind);
        writer.writeObjectValue<ObjectMeta>("metadata", replicaSet.metadata, serializeObjectMeta);
        writer.writeObjectValue<ReplicaSetSpec>("spec", replicaSet.spec, serializeReplicaSetSpec);
        writer.writeObjectValue<ReplicaSetStatus>("status", replicaSet.status, serializeReplicaSetStatus);
        writer.writeAdditionalData(replicaSet.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeReplicaSetCondition(writer: SerializationWriter, replicaSetCondition: Partial<ReplicaSetCondition> | undefined | null = {}) : void {
    if (replicaSetCondition) {
        writer.writeDateValue("lastTransitionTime", replicaSetCondition.lastTransitionTime);
        writer.writeStringValue("message", replicaSetCondition.message);
        writer.writeStringValue("reason", replicaSetCondition.reason);
        writer.writeStringValue("status", replicaSetCondition.status);
        writer.writeStringValue("type", replicaSetCondition.type);
        writer.writeAdditionalData(replicaSetCondition.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeReplicaSetList(writer: SerializationWriter, replicaSetList: Partial<ReplicaSetList> | undefined | null = {}) : void {
    if (replicaSetList) {
        writer.writeStringValue("apiVersion", replicaSetList.apiVersion);
        writer.writeCollectionOfObjectValues<ReplicaSet>("items", replicaSetList.items, serializeReplicaSet);
        writer.writeStringValue("kind", replicaSetList.kind);
        writer.writeObjectValue<ListMeta>("metadata", replicaSetList.metadata, serializeListMeta);
        writer.writeAdditionalData(replicaSetList.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeReplicaSetSpec(writer: SerializationWriter, replicaSetSpec: Partial<ReplicaSetSpec> | undefined | null = {}) : void {
    if (replicaSetSpec) {
        writer.writeNumberValue("minReadySeconds", replicaSetSpec.minReadySeconds);
        writer.writeNumberValue("replicas", replicaSetSpec.replicas);
        writer.writeObjectValue<LabelSelector>("selector", replicaSetSpec.selector, serializeLabelSelector);
        writer.writeObjectValue<PodTemplateSpec>("template", replicaSetSpec.template, serializePodTemplateSpec);
        writer.writeAdditionalData(replicaSetSpec.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeReplicaSetStatus(writer: SerializationWriter, replicaSetStatus: Partial<ReplicaSetStatus> | undefined | null = {}) : void {
    if (replicaSetStatus) {
        writer.writeNumberValue("availableReplicas", replicaSetStatus.availableReplicas);
        writer.writeCollectionOfObjectValues<ReplicaSetCondition>("conditions", replicaSetStatus.conditions, serializeReplicaSetCondition);
        writer.writeNumberValue("fullyLabeledReplicas", replicaSetStatus.fullyLabeledReplicas);
        writer.writeNumberValue("observedGeneration", replicaSetStatus.observedGeneration);
        writer.writeNumberValue("readyReplicas", replicaSetStatus.readyReplicas);
        writer.writeNumberValue("replicas", replicaSetStatus.replicas);
        writer.writeNumberValue("terminatingReplicas", replicaSetStatus.terminatingReplicas);
        writer.writeAdditionalData(replicaSetStatus.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRollingUpdateDaemonSet(writer: SerializationWriter, rollingUpdateDaemonSet: Partial<RollingUpdateDaemonSet> | undefined | null = {}) : void {
    if (rollingUpdateDaemonSet) {
        writer.writeStringValue("maxSurge", rollingUpdateDaemonSet.maxSurge);
        writer.writeStringValue("maxUnavailable", rollingUpdateDaemonSet.maxUnavailable);
        writer.writeAdditionalData(rollingUpdateDaemonSet.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRollingUpdateDeployment(writer: SerializationWriter, rollingUpdateDeployment: Partial<RollingUpdateDeployment> | undefined | null = {}) : void {
    if (rollingUpdateDeployment) {
        writer.writeStringValue("maxSurge", rollingUpdateDeployment.maxSurge);
        writer.writeStringValue("maxUnavailable", rollingUpdateDeployment.maxUnavailable);
        writer.writeAdditionalData(rollingUpdateDeployment.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRollingUpdateStatefulSetStrategy(writer: SerializationWriter, rollingUpdateStatefulSetStrategy: Partial<RollingUpdateStatefulSetStrategy> | undefined | null = {}) : void {
    if (rollingUpdateStatefulSetStrategy) {
        writer.writeStringValue("maxUnavailable", rollingUpdateStatefulSetStrategy.maxUnavailable);
        writer.writeNumberValue("partition", rollingUpdateStatefulSetStrategy.partition);
        writer.writeAdditionalData(rollingUpdateStatefulSetStrategy.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStatefulSet(writer: SerializationWriter, statefulSet: Partial<StatefulSet> | undefined | null = {}) : void {
    if (statefulSet) {
        writer.writeStringValue("apiVersion", statefulSet.apiVersion);
        writer.writeStringValue("kind", statefulSet.kind);
        writer.writeObjectValue<ObjectMeta>("metadata", statefulSet.metadata, serializeObjectMeta);
        writer.writeObjectValue<StatefulSetSpec>("spec", statefulSet.spec, serializeStatefulSetSpec);
        writer.writeObjectValue<StatefulSetStatus>("status", statefulSet.status, serializeStatefulSetStatus);
        writer.writeAdditionalData(statefulSet.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStatefulSetCondition(writer: SerializationWriter, statefulSetCondition: Partial<StatefulSetCondition> | undefined | null = {}) : void {
    if (statefulSetCondition) {
        writer.writeDateValue("lastTransitionTime", statefulSetCondition.lastTransitionTime);
        writer.writeStringValue("message", statefulSetCondition.message);
        writer.writeStringValue("reason", statefulSetCondition.reason);
        writer.writeStringValue("status", statefulSetCondition.status);
        writer.writeStringValue("type", statefulSetCondition.type);
        writer.writeAdditionalData(statefulSetCondition.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStatefulSetList(writer: SerializationWriter, statefulSetList: Partial<StatefulSetList> | undefined | null = {}) : void {
    if (statefulSetList) {
        writer.writeStringValue("apiVersion", statefulSetList.apiVersion);
        writer.writeCollectionOfObjectValues<StatefulSet>("items", statefulSetList.items, serializeStatefulSet);
        writer.writeStringValue("kind", statefulSetList.kind);
        writer.writeObjectValue<ListMeta>("metadata", statefulSetList.metadata, serializeListMeta);
        writer.writeAdditionalData(statefulSetList.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStatefulSetOrdinals(writer: SerializationWriter, statefulSetOrdinals: Partial<StatefulSetOrdinals> | undefined | null = {}) : void {
    if (statefulSetOrdinals) {
        writer.writeNumberValue("start", statefulSetOrdinals.start);
        writer.writeAdditionalData(statefulSetOrdinals.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStatefulSetPersistentVolumeClaimRetentionPolicy(writer: SerializationWriter, statefulSetPersistentVolumeClaimRetentionPolicy: Partial<StatefulSetPersistentVolumeClaimRetentionPolicy> | undefined | null = {}) : void {
    if (statefulSetPersistentVolumeClaimRetentionPolicy) {
        writer.writeStringValue("whenDeleted", statefulSetPersistentVolumeClaimRetentionPolicy.whenDeleted);
        writer.writeStringValue("whenScaled", statefulSetPersistentVolumeClaimRetentionPolicy.whenScaled);
        writer.writeAdditionalData(statefulSetPersistentVolumeClaimRetentionPolicy.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStatefulSetSpec(writer: SerializationWriter, statefulSetSpec: Partial<StatefulSetSpec> | undefined | null = {}) : void {
    if (statefulSetSpec) {
        writer.writeNumberValue("minReadySeconds", statefulSetSpec.minReadySeconds);
        writer.writeObjectValue<StatefulSetOrdinals>("ordinals", statefulSetSpec.ordinals, serializeStatefulSetOrdinals);
        writer.writeObjectValue<StatefulSetPersistentVolumeClaimRetentionPolicy>("persistentVolumeClaimRetentionPolicy", statefulSetSpec.persistentVolumeClaimRetentionPolicy, serializeStatefulSetPersistentVolumeClaimRetentionPolicy);
        writer.writeStringValue("podManagementPolicy", statefulSetSpec.podManagementPolicy);
        writer.writeNumberValue("replicas", statefulSetSpec.replicas);
        writer.writeNumberValue("revisionHistoryLimit", statefulSetSpec.revisionHistoryLimit);
        writer.writeObjectValue<LabelSelector>("selector", statefulSetSpec.selector, serializeLabelSelector);
        writer.writeStringValue("serviceName", statefulSetSpec.serviceName);
        writer.writeObjectValue<PodTemplateSpec>("template", statefulSetSpec.template, serializePodTemplateSpec);
        writer.writeObjectValue<StatefulSetUpdateStrategy>("updateStrategy", statefulSetSpec.updateStrategy, serializeStatefulSetUpdateStrategy);
        writer.writeCollectionOfObjectValues<PersistentVolumeClaim>("volumeClaimTemplates", statefulSetSpec.volumeClaimTemplates, serializePersistentVolumeClaim);
        writer.writeAdditionalData(statefulSetSpec.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStatefulSetStatus(writer: SerializationWriter, statefulSetStatus: Partial<StatefulSetStatus> | undefined | null = {}) : void {
    if (statefulSetStatus) {
        writer.writeNumberValue("availableReplicas", statefulSetStatus.availableReplicas);
        writer.writeNumberValue("collisionCount", statefulSetStatus.collisionCount);
        writer.writeCollectionOfObjectValues<StatefulSetCondition>("conditions", statefulSetStatus.conditions, serializeStatefulSetCondition);
        writer.writeNumberValue("currentReplicas", statefulSetStatus.currentReplicas);
        writer.writeStringValue("currentRevision", statefulSetStatus.currentRevision);
        writer.writeNumberValue("observedGeneration", statefulSetStatus.observedGeneration);
        writer.writeNumberValue("readyReplicas", statefulSetStatus.readyReplicas);
        writer.writeNumberValue("replicas", statefulSetStatus.replicas);
        writer.writeNumberValue("updatedReplicas", statefulSetStatus.updatedReplicas);
        writer.writeStringValue("updateRevision", statefulSetStatus.updateRevision);
        writer.writeAdditionalData(statefulSetStatus.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStatefulSetUpdateStrategy(writer: SerializationWriter, statefulSetUpdateStrategy: Partial<StatefulSetUpdateStrategy> | undefined | null = {}) : void {
    if (statefulSetUpdateStrategy) {
        writer.writeObjectValue<RollingUpdateStatefulSetStrategy>("rollingUpdate", statefulSetUpdateStrategy.rollingUpdate, serializeRollingUpdateStatefulSetStrategy);
        writer.writeStringValue("type", statefulSetUpdateStrategy.type);
        writer.writeAdditionalData(statefulSetUpdateStrategy.additionalData);
    }
}
/**
 * StatefulSet represents a set of pods with consistent identities. Identities are defined as:  - Network: A single stable DNS and hostname.  - Storage: As many VolumeClaims as requested.The StatefulSet guarantees that a given network identity will always map to the same storage identity.
 */
export interface StatefulSet extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
     */
    metadata?: ObjectMeta | null;
    /**
     * A StatefulSetSpec is the specification of a StatefulSet.
     */
    spec?: StatefulSetSpec | null;
    /**
     * StatefulSetStatus represents the current state of a StatefulSet.
     */
    status?: StatefulSetStatus | null;
}
/**
 * StatefulSetCondition describes the state of a statefulset at a certain point.
 */
export interface StatefulSetCondition extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
     */
    lastTransitionTime?: Date | null;
    /**
     * A human readable message indicating details about the transition.
     */
    message?: string | null;
    /**
     * The reason for the condition's last transition.
     */
    reason?: string | null;
    /**
     * Status of the condition, one of True, False, Unknown.
     */
    status?: string | null;
    /**
     * Type of statefulset condition.
     */
    type?: string | null;
}
/**
 * StatefulSetList is a collection of StatefulSets.
 */
export interface StatefulSetList extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * Items is the list of stateful sets.
     */
    items?: StatefulSet[] | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
     */
    metadata?: ListMeta | null;
}
/**
 * StatefulSetOrdinals describes the policy used for replica ordinal assignment in this StatefulSet.
 */
export interface StatefulSetOrdinals extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * start is the number representing the first replica's index. It may be used to number replicas from an alternate index (eg: 1-indexed) over the default 0-indexed names, or to orchestrate progressive movement of replicas from one StatefulSet to another. If set, replica indices will be in the range:  [.spec.ordinals.start, .spec.ordinals.start + .spec.replicas).If unset, defaults to 0. Replica indices will be in the range:  [0, .spec.replicas).
     */
    start?: number | null;
}
/**
 * StatefulSetPersistentVolumeClaimRetentionPolicy describes the policy used for PVCs created from the StatefulSet VolumeClaimTemplates.
 */
export interface StatefulSetPersistentVolumeClaimRetentionPolicy extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * WhenDeleted specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is deleted. The default policy of `Retain` causes PVCs to not be affected by StatefulSet deletion. The `Delete` policy causes those PVCs to be deleted.
     */
    whenDeleted?: string | null;
    /**
     * WhenScaled specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is scaled down. The default policy of `Retain` causes PVCs to not be affected by a scaledown. The `Delete` policy causes the associated PVCs for any excess pods above the replica count to be deleted.
     */
    whenScaled?: string | null;
}
/**
 * A StatefulSetSpec is the specification of a StatefulSet.
 */
export interface StatefulSetSpec extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Minimum number of seconds for which a newly created pod should be ready without any of its container crashing for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
     */
    minReadySeconds?: number | null;
    /**
     * StatefulSetOrdinals describes the policy used for replica ordinal assignment in this StatefulSet.
     */
    ordinals?: StatefulSetOrdinals | null;
    /**
     * StatefulSetPersistentVolumeClaimRetentionPolicy describes the policy used for PVCs created from the StatefulSet VolumeClaimTemplates.
     */
    persistentVolumeClaimRetentionPolicy?: StatefulSetPersistentVolumeClaimRetentionPolicy | null;
    /**
     * podManagementPolicy controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is `Parallel` which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.
     */
    podManagementPolicy?: string | null;
    /**
     * replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template, but individual replicas also have a consistent identity. If unspecified, defaults to 1.
     */
    replicas?: number | null;
    /**
     * revisionHistoryLimit is the maximum number of revisions that will be maintained in the StatefulSet's revision history. The revision history consists of all revisions not represented by a currently applied StatefulSetSpec version. The default value is 10.
     */
    revisionHistoryLimit?: number | null;
    /**
     * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
     */
    selector?: LabelSelector | null;
    /**
     * serviceName is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. Pods get DNS/hostnames that follow the pattern: pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is managed by the StatefulSet controller.
     */
    serviceName?: string | null;
    /**
     * PodTemplateSpec describes the data a pod should have when created from a template
     */
    template?: PodTemplateSpec | null;
    /**
     * StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.
     */
    updateStrategy?: StatefulSetUpdateStrategy | null;
    /**
     * volumeClaimTemplates is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. A claim in this list takes precedence over any volumes in the template, with the same name.
     */
    volumeClaimTemplates?: PersistentVolumeClaim[] | null;
}
/**
 * StatefulSetStatus represents the current state of a StatefulSet.
 */
export interface StatefulSetStatus extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset.
     */
    availableReplicas?: number | null;
    /**
     * collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
     */
    collisionCount?: number | null;
    /**
     * Represents the latest available observations of a statefulset's current state.
     */
    conditions?: StatefulSetCondition[] | null;
    /**
     * currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by currentRevision.
     */
    currentReplicas?: number | null;
    /**
     * currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [0,currentReplicas).
     */
    currentRevision?: string | null;
    /**
     * observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the StatefulSet's generation, which is updated on mutation by the API Server.
     */
    observedGeneration?: number | null;
    /**
     * readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.
     */
    readyReplicas?: number | null;
    /**
     * replicas is the number of Pods created by the StatefulSet controller.
     */
    replicas?: number | null;
    /**
     * updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by updateRevision.
     */
    updatedReplicas?: number | null;
    /**
     * updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [replicas-updatedReplicas,replicas)
     */
    updateRevision?: string | null;
}
/**
 * StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.
 */
export interface StatefulSetUpdateStrategy extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
     */
    rollingUpdate?: RollingUpdateStatefulSetStrategy | null;
    /**
     * Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
     */
    type?: string | null;
}
/* tslint:enable */
/* eslint-enable */
