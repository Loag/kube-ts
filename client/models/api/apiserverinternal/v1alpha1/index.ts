/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createListMetaFromDiscriminatorValue, createObjectMetaFromDiscriminatorValue, serializeListMeta, serializeObjectMeta, type ListMeta, type ObjectMeta } from '../../../apimachinery/pkg/apis/meta/v1/index.js';
// @ts-ignore
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ServerStorageVersion}
 */
// @ts-ignore
export function createServerStorageVersionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoServerStorageVersion;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StorageVersionCondition}
 */
// @ts-ignore
export function createStorageVersionConditionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStorageVersionCondition;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StorageVersion}
 */
// @ts-ignore
export function createStorageVersionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStorageVersion;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StorageVersionList}
 */
// @ts-ignore
export function createStorageVersionListFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStorageVersionList;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StorageVersionSpec}
 */
// @ts-ignore
export function createStorageVersionSpecFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStorageVersionSpec;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {StorageVersionStatus}
 */
// @ts-ignore
export function createStorageVersionStatusFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoStorageVersionStatus;
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoServerStorageVersion(serverStorageVersion: Partial<ServerStorageVersion> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiServerID": n => { serverStorageVersion.apiServerID = n.getStringValue(); },
        "decodableVersions": n => { serverStorageVersion.decodableVersions = n.getCollectionOfPrimitiveValues<string>(); },
        "encodingVersion": n => { serverStorageVersion.encodingVersion = n.getStringValue(); },
        "servedVersions": n => { serverStorageVersion.servedVersions = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStorageVersion(storageVersion: Partial<StorageVersion> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { storageVersion.apiVersion = n.getStringValue(); },
        "kind": n => { storageVersion.kind = n.getStringValue(); },
        "metadata": n => { storageVersion.metadata = n.getObjectValue<ObjectMeta>(createObjectMetaFromDiscriminatorValue); },
        "spec": n => { storageVersion.spec = n.getObjectValue<StorageVersionSpec>(createStorageVersionSpecFromDiscriminatorValue); },
        "status": n => { storageVersion.status = n.getObjectValue<StorageVersionStatus>(createStorageVersionStatusFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStorageVersionCondition(storageVersionCondition: Partial<StorageVersionCondition> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "lastTransitionTime": n => { storageVersionCondition.lastTransitionTime = n.getDateValue(); },
        "message": n => { storageVersionCondition.message = n.getStringValue(); },
        "observedGeneration": n => { storageVersionCondition.observedGeneration = n.getNumberValue(); },
        "reason": n => { storageVersionCondition.reason = n.getStringValue(); },
        "status": n => { storageVersionCondition.status = n.getStringValue(); },
        "type": n => { storageVersionCondition.type = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStorageVersionList(storageVersionList: Partial<StorageVersionList> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { storageVersionList.apiVersion = n.getStringValue(); },
        "items": n => { storageVersionList.items = n.getCollectionOfObjectValues<StorageVersion>(createStorageVersionFromDiscriminatorValue); },
        "kind": n => { storageVersionList.kind = n.getStringValue(); },
        "metadata": n => { storageVersionList.metadata = n.getObjectValue<ListMeta>(createListMetaFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStorageVersionSpec(storageVersionSpec: Partial<StorageVersionSpec> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoStorageVersionStatus(storageVersionStatus: Partial<StorageVersionStatus> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "commonEncodingVersion": n => { storageVersionStatus.commonEncodingVersion = n.getStringValue(); },
        "conditions": n => { storageVersionStatus.conditions = n.getCollectionOfObjectValues<StorageVersionCondition>(createStorageVersionConditionFromDiscriminatorValue); },
        "storageVersions": n => { storageVersionStatus.storageVersions = n.getCollectionOfObjectValues<ServerStorageVersion>(createServerStorageVersionFromDiscriminatorValue); },
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeServerStorageVersion(writer: SerializationWriter, serverStorageVersion: Partial<ServerStorageVersion> | undefined | null = {}) : void {
    if (serverStorageVersion) {
        writer.writeStringValue("apiServerID", serverStorageVersion.apiServerID);
        writer.writeCollectionOfPrimitiveValues<string>("decodableVersions", serverStorageVersion.decodableVersions);
        writer.writeStringValue("encodingVersion", serverStorageVersion.encodingVersion);
        writer.writeCollectionOfPrimitiveValues<string>("servedVersions", serverStorageVersion.servedVersions);
        writer.writeAdditionalData(serverStorageVersion.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStorageVersion(writer: SerializationWriter, storageVersion: Partial<StorageVersion> | undefined | null = {}) : void {
    if (storageVersion) {
        writer.writeStringValue("apiVersion", storageVersion.apiVersion);
        writer.writeStringValue("kind", storageVersion.kind);
        writer.writeObjectValue<ObjectMeta>("metadata", storageVersion.metadata, serializeObjectMeta);
        writer.writeObjectValue<StorageVersionSpec>("spec", storageVersion.spec, serializeStorageVersionSpec);
        writer.writeObjectValue<StorageVersionStatus>("status", storageVersion.status, serializeStorageVersionStatus);
        writer.writeAdditionalData(storageVersion.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStorageVersionCondition(writer: SerializationWriter, storageVersionCondition: Partial<StorageVersionCondition> | undefined | null = {}) : void {
    if (storageVersionCondition) {
        writer.writeDateValue("lastTransitionTime", storageVersionCondition.lastTransitionTime);
        writer.writeStringValue("message", storageVersionCondition.message);
        writer.writeNumberValue("observedGeneration", storageVersionCondition.observedGeneration);
        writer.writeStringValue("reason", storageVersionCondition.reason);
        writer.writeStringValue("status", storageVersionCondition.status);
        writer.writeStringValue("type", storageVersionCondition.type);
        writer.writeAdditionalData(storageVersionCondition.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStorageVersionList(writer: SerializationWriter, storageVersionList: Partial<StorageVersionList> | undefined | null = {}) : void {
    if (storageVersionList) {
        writer.writeStringValue("apiVersion", storageVersionList.apiVersion);
        writer.writeCollectionOfObjectValues<StorageVersion>("items", storageVersionList.items, serializeStorageVersion);
        writer.writeStringValue("kind", storageVersionList.kind);
        writer.writeObjectValue<ListMeta>("metadata", storageVersionList.metadata, serializeListMeta);
        writer.writeAdditionalData(storageVersionList.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStorageVersionSpec(writer: SerializationWriter, storageVersionSpec: Partial<StorageVersionSpec> | undefined | null = {}) : void {
    if (storageVersionSpec) {
        writer.writeAdditionalData(storageVersionSpec.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeStorageVersionStatus(writer: SerializationWriter, storageVersionStatus: Partial<StorageVersionStatus> | undefined | null = {}) : void {
    if (storageVersionStatus) {
        writer.writeStringValue("commonEncodingVersion", storageVersionStatus.commonEncodingVersion);
        writer.writeCollectionOfObjectValues<StorageVersionCondition>("conditions", storageVersionStatus.conditions, serializeStorageVersionCondition);
        writer.writeCollectionOfObjectValues<ServerStorageVersion>("storageVersions", storageVersionStatus.storageVersions, serializeServerStorageVersion);
        writer.writeAdditionalData(storageVersionStatus.additionalData);
    }
}
/**
 * An API server instance reports the version it can decode and the version it encodes objects to when persisting objects in the backend.
 */
export interface ServerStorageVersion extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The ID of the reporting API server.
     */
    apiServerID?: string | null;
    /**
     * The API server can decode objects encoded in these versions. The encodingVersion must be included in the decodableVersions.
     */
    decodableVersions?: string[] | null;
    /**
     * The API server encodes the object to this version when persisting it in the backend (e.g., etcd).
     */
    encodingVersion?: string | null;
    /**
     * The API server can serve these versions. DecodableVersions must include all ServedVersions.
     */
    servedVersions?: string[] | null;
}
/**
 * Storage version of a specific resource.
 */
export interface StorageVersion extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
     */
    metadata?: ObjectMeta | null;
    /**
     * StorageVersionSpec is an empty spec.
     */
    spec?: StorageVersionSpec | null;
    /**
     * API server instances report the versions they can decode and the version they encode objects to when persisting objects in the backend.
     */
    status?: StorageVersionStatus | null;
}
/**
 * Describes the state of the storageVersion at a certain point.
 */
export interface StorageVersionCondition extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
     */
    lastTransitionTime?: Date | null;
    /**
     * A human readable message indicating details about the transition.
     */
    message?: string | null;
    /**
     * If set, this represents the .metadata.generation that the condition was set based upon.
     */
    observedGeneration?: number | null;
    /**
     * The reason for the condition's last transition.
     */
    reason?: string | null;
    /**
     * Status of the condition, one of True, False, Unknown.
     */
    status?: string | null;
    /**
     * Type of the condition.
     */
    type?: string | null;
}
/**
 * A list of StorageVersions.
 */
export interface StorageVersionList extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * Items holds a list of StorageVersion
     */
    items?: StorageVersion[] | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
     */
    metadata?: ListMeta | null;
}
/**
 * StorageVersionSpec is an empty spec.
 */
export interface StorageVersionSpec extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
}
/**
 * API server instances report the versions they can decode and the version they encode objects to when persisting objects in the backend.
 */
export interface StorageVersionStatus extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * If all API server instances agree on the same encoding storage version, then this field is set to that version. Otherwise this field is left empty. API servers should finish updating its storageVersionStatus entry before serving write operations, so that this field will be in sync with the reality.
     */
    commonEncodingVersion?: string | null;
    /**
     * The latest available observations of the storageVersion's state.
     */
    conditions?: StorageVersionCondition[] | null;
    /**
     * The reported versions per API server instance.
     */
    storageVersions?: ServerStorageVersion[] | null;
}
/* tslint:enable */
/* eslint-enable */
