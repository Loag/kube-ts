/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createListMetaFromDiscriminatorValue, createObjectMetaFromDiscriminatorValue, serializeListMeta, serializeObjectMeta, type ListMeta, type ObjectMeta } from '../../../apimachinery/pkg/apis/meta/v1/index.js';
// @ts-ignore
import { createEventSourceFromDiscriminatorValue, createObjectReferenceFromDiscriminatorValue, serializeEventSource, serializeObjectReference, type EventSource, type ObjectReference } from '../../core/v1/index.js';
// @ts-ignore
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Event}
 */
// @ts-ignore
export function createEventFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEvent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EventList}
 */
// @ts-ignore
export function createEventListFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEventList;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EventSeries}
 */
// @ts-ignore
export function createEventSeriesFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEventSeries;
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoEvent(event: Partial<Event> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "action": n => { event.action = n.getStringValue(); },
        "apiVersion": n => { event.apiVersion = n.getStringValue(); },
        "deprecatedCount": n => { event.deprecatedCount = n.getNumberValue(); },
        "deprecatedFirstTimestamp": n => { event.deprecatedFirstTimestamp = n.getDateValue(); },
        "deprecatedLastTimestamp": n => { event.deprecatedLastTimestamp = n.getDateValue(); },
        "deprecatedSource": n => { event.deprecatedSource = n.getObjectValue<EventSource>(createEventSourceFromDiscriminatorValue); },
        "eventTime": n => { event.eventTime = n.getDateValue(); },
        "kind": n => { event.kind = n.getStringValue(); },
        "metadata": n => { event.metadata = n.getObjectValue<ObjectMeta>(createObjectMetaFromDiscriminatorValue); },
        "note": n => { event.note = n.getStringValue(); },
        "reason": n => { event.reason = n.getStringValue(); },
        "regarding": n => { event.regarding = n.getObjectValue<ObjectReference>(createObjectReferenceFromDiscriminatorValue); },
        "related": n => { event.related = n.getObjectValue<ObjectReference>(createObjectReferenceFromDiscriminatorValue); },
        "reportingController": n => { event.reportingController = n.getStringValue(); },
        "reportingInstance": n => { event.reportingInstance = n.getStringValue(); },
        "series": n => { event.series = n.getObjectValue<EventSeries>(createEventSeriesFromDiscriminatorValue); },
        "type": n => { event.type = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoEventList(eventList: Partial<EventList> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "apiVersion": n => { eventList.apiVersion = n.getStringValue(); },
        "items": n => { eventList.items = n.getCollectionOfObjectValues<Event>(createEventFromDiscriminatorValue); },
        "kind": n => { eventList.kind = n.getStringValue(); },
        "metadata": n => { eventList.metadata = n.getObjectValue<ListMeta>(createListMetaFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoEventSeries(eventSeries: Partial<EventSeries> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "count": n => { eventSeries.count = n.getNumberValue(); },
        "lastObservedTime": n => { eventSeries.lastObservedTime = n.getDateValue(); },
    }
}
/**
 * Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data.
 */
export interface Event extends AdditionalDataHolder, Parsable {
    /**
     * action is what action was taken/failed regarding to the regarding object. It is machine-readable. This field cannot be empty for new Events and it can have at most 128 characters.
     */
    action?: string | null;
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * deprecatedCount is the deprecated field assuring backward compatibility with core.v1 Event type.
     */
    deprecatedCount?: number | null;
    /**
     * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
     */
    deprecatedFirstTimestamp?: Date | null;
    /**
     * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
     */
    deprecatedLastTimestamp?: Date | null;
    /**
     * EventSource contains information for an event.
     */
    deprecatedSource?: EventSource | null;
    /**
     * MicroTime is version of Time with microsecond level precision.
     */
    eventTime?: Date | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
     */
    metadata?: ObjectMeta | null;
    /**
     * note is a human-readable description of the status of this operation. Maximal length of the note is 1kB, but libraries should be prepared to handle values up to 64kB.
     */
    note?: string | null;
    /**
     * reason is why the action was taken. It is human-readable. This field cannot be empty for new Events and it can have at most 128 characters.
     */
    reason?: string | null;
    /**
     * ObjectReference contains enough information to let you inspect or modify the referred object.
     */
    regarding?: ObjectReference | null;
    /**
     * ObjectReference contains enough information to let you inspect or modify the referred object.
     */
    related?: ObjectReference | null;
    /**
     * reportingController is the name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`. This field cannot be empty for new Events.
     */
    reportingController?: string | null;
    /**
     * reportingInstance is the ID of the controller instance, e.g. `kubelet-xyzf`. This field cannot be empty for new Events and it can have at most 128 characters.
     */
    reportingInstance?: string | null;
    /**
     * EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time. How often to update the EventSeries is up to the event reporters. The default event reporter in "k8s.io/client-go/tools/events/event_broadcaster.go" shows how this struct is updated on heartbeats and can guide customized reporter implementations.
     */
    series?: EventSeries | null;
    /**
     * type is the type of this event (Normal, Warning), new types could be added in the future. It is machine-readable. This field cannot be empty for new Events.
     */
    type?: string | null;
}
/**
 * EventList is a list of Event objects.
 */
export interface EventList extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
     */
    apiVersion?: string | null;
    /**
     * items is a list of schema objects.
     */
    items?: Event[] | null;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     */
    kind?: string | null;
    /**
     * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
     */
    metadata?: ListMeta | null;
}
/**
 * EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time. How often to update the EventSeries is up to the event reporters. The default event reporter in "k8s.io/client-go/tools/events/event_broadcaster.go" shows how this struct is updated on heartbeats and can guide customized reporter implementations.
 */
export interface EventSeries extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * count is the number of occurrences in this series up to the last heartbeat time.
     */
    count?: number | null;
    /**
     * MicroTime is version of Time with microsecond level precision.
     */
    lastObservedTime?: Date | null;
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeEvent(writer: SerializationWriter, event: Partial<Event> | undefined | null = {}) : void {
    if (event) {
        writer.writeStringValue("action", event.action);
        writer.writeStringValue("apiVersion", event.apiVersion);
        writer.writeNumberValue("deprecatedCount", event.deprecatedCount);
        writer.writeDateValue("deprecatedFirstTimestamp", event.deprecatedFirstTimestamp);
        writer.writeDateValue("deprecatedLastTimestamp", event.deprecatedLastTimestamp);
        writer.writeObjectValue<EventSource>("deprecatedSource", event.deprecatedSource, serializeEventSource);
        writer.writeDateValue("eventTime", event.eventTime);
        writer.writeStringValue("kind", event.kind);
        writer.writeObjectValue<ObjectMeta>("metadata", event.metadata, serializeObjectMeta);
        writer.writeStringValue("note", event.note);
        writer.writeStringValue("reason", event.reason);
        writer.writeObjectValue<ObjectReference>("regarding", event.regarding, serializeObjectReference);
        writer.writeObjectValue<ObjectReference>("related", event.related, serializeObjectReference);
        writer.writeStringValue("reportingController", event.reportingController);
        writer.writeStringValue("reportingInstance", event.reportingInstance);
        writer.writeObjectValue<EventSeries>("series", event.series, serializeEventSeries);
        writer.writeStringValue("type", event.type);
        writer.writeAdditionalData(event.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeEventList(writer: SerializationWriter, eventList: Partial<EventList> | undefined | null = {}) : void {
    if (eventList) {
        writer.writeStringValue("apiVersion", eventList.apiVersion);
        writer.writeCollectionOfObjectValues<Event>("items", eventList.items, serializeEvent);
        writer.writeStringValue("kind", eventList.kind);
        writer.writeObjectValue<ListMeta>("metadata", eventList.metadata, serializeListMeta);
        writer.writeAdditionalData(eventList.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeEventSeries(writer: SerializationWriter, eventSeries: Partial<EventSeries> | undefined | null = {}) : void {
    if (eventSeries) {
        writer.writeNumberValue("count", eventSeries.count);
        writer.writeDateValue("lastObservedTime", eventSeries.lastObservedTime);
        writer.writeAdditionalData(eventSeries.additionalData);
    }
}
/* tslint:enable */
/* eslint-enable */
